{"ast":null,"code":"//Helper function for Distance(in m) between global points\n\n/**\n * @param {*} firstLocation\n * @param {*} secondLocation\n * @id N2.1.1\n * @author Ushaswini Chintha\n * @description get global distance between two points\n */\nexport const getHaversineDistance = (firstLocation, secondLocation) => {\n  const earthRadius = 6371; // km //6378137; //m\n\n  const diffLat = (secondLocation.lat - firstLocation.lat) * Math.PI / 180;\n  const difflon = (secondLocation.lon - firstLocation.lon) * Math.PI / 180; // console.log(\"difflat,difflon\",diffLat,difflon,firstLocation, secondLocation)\n\n  const arc = Math.cos(firstLocation.lat * Math.PI / 180) * Math.cos(secondLocation.lat * Math.PI / 180) * Math.sin(difflon / 2) * Math.sin(difflon / 2) + Math.sin(diffLat / 2) * Math.sin(diffLat / 2);\n  const line = 2 * Math.atan2(Math.sqrt(arc), Math.sqrt(1 - arc));\n  const distance = earthRadius * line * 1000;\n  return distance;\n}; //calculates Gcoordinates with given vertical and horizontal distance (should be in meters) from a refrence point\n\n/**\n * @param {*} reference\n * @param {*} vertical\n * @param {*} horizontal\n * @id N2.1.2\n * @author Ushaswini Chintha\n * @description get coordinates from reference points\n */\n\nexport const obtaincoordinates = (reference, vertical, horizontal) => {\n  const R = 6378137; //Earthâ€™s radius, sphere\n  //Coordinate offsets in radians\n\n  var dLat = vertical / R;\n  var dLon = horizontal / (R * Math.cos(Math.PI * reference.lat / 180)); //OffsetPosition, decimal degrees\n\n  var latA = reference.lat + dLat * 180 / Math.PI;\n  var lonA = reference.lon + dLon * 180 / Math.PI;\n  return {\n    lat: latA,\n    lon: lonA\n  };\n};\n/**\n *\n * @param {*} first\n * @param {*} second\n * @id N2.1.3\n * @author Ushaswini Chintha\n * @description distance between two coorinates\n */\n//helper function for distance between two points in local coordinates\n\nexport const distance = (first, second) => {\n  var dist = (second.localy - first.localy) ** 2 + (second.localx - first.localx) ** 2;\n  return Math.sqrt(dist);\n};\n/**\n *\n * @param {*} one\n * @param {*} two\n * @param {*} three\n * @id N2.1.4\n * @author Ushaswini Chintha\n * @description get perpendicalr from 3 points\n */\n//perpendicular distance of point(three) from a line formed by one and two\n\nexport const perpendicular = (one, two, three) => {\n  var y = Math.sin(three.lon - one.lon) * Math.cos(three.lat);\n  var x = Math.cos(one.lat) * Math.sin(three.lat) - Math.sin(one.lat) * Math.cos(three.lat) * Math.cos(three.lat - one.lat);\n  var bearing1 = Math.atan2(y, x) * 180 / Math.PI;\n  bearing1 = 360 - (bearing1 + 360) % 360;\n  var y2 = Math.sin(two.lon - one.lon) * Math.cos(two.lat);\n  var x2 = Math.cos(one.lat) * Math.sin(two.lat) - Math.sin(one.lat) * Math.cos(two.lat) * Math.cos(two.lat - one.lat);\n  var bearing2 = Math.atan2(y2, x2) * 180 / Math.PI;\n  bearing2 = 360 - (bearing2 + 360) % 360;\n  var lat1Rads = one.lat * Math.PI / 180;\n  var lat3Rads = three.lat * Math.PI / 180;\n  var dLon = (three.lon - one.lon) * Math.PI / 180;\n  var distanceAC = Math.acos(Math.sin(lat1Rads) * Math.sin(lat3Rads) + Math.cos(lat1Rads) * Math.cos(lat3Rads) * Math.cos(dLon)) * 6371;\n  var min_distance = Math.abs(Math.asin(Math.sin(distanceAC / 6371) * Math.sin(bearing1 * Math.PI / 180 - bearing2 * Math.PI / 180)) * 6371); // console.log(\"The perpendicular distance is: \", min_distance*1000*3.28084);\n\n  return min_distance * 1000 * 3.28084;\n}; //angle between three points; type:0 -> normal_distance, type:1 -> haversine_distance\n\n/**\n *\n * @param {*} one\n * @param {*} two\n * @param {*} three\n * @param {*} type\n * @id N2.1.5\n * @author Ushaswini Chintha\n * @description angle between reference points\n */\n\nexport const angle = (one, two, three, type) => {\n  if (type == 0) {\n    //calulated using normal_distance\n    var l = this.distance(one, two);\n    var m = this.distance(two, three);\n    var n = this.distance(one, three);\n    var theta = Math.acos((l * l + n * n - m * m) / (2 * l * n)) * 180 / Math.PI;\n\n    if ((l * l + n * n - m * m) / (2 * l * n) > 1 || m == 0 || n == 0) {\n      theta = 0;\n    } //straight line case\n\n\n    if ((l * l + n * n - m * m) / (2 * l * n) < -1) {\n      theta = 180;\n    } //straight line case\n\n  } else if (type == 1) {\n    //calulated using haverisine_distance\n    var b = this.getHaversineDistance(one, two);\n    var c = this.getHaversineDistance(one, three);\n    var a = this.getHaversineDistance(two, three);\n    var theta = Math.acos((b * b + c * c - a * a) / (2 * b * c)) * 180 / Math.PI;\n\n    if ((b * b + c * c - a * a) / (2 * b * c) > 1 || a == 0 || c == 0) {\n      theta = 0;\n    } //straight line case\n\n\n    if ((b * b + c * c - a * a) / (2 * b * c) < -1) {\n      theta = 180;\n    } //straight line case\n\n  }\n\n  return theta;\n};\n/**\n *\n * @param {*} coords\n * @param {*} red_data\n * @param {*} entrance_point\n * @param {*} drop_points\n * @id N2.1.6\n * @author Ushaswini Chintha\n * @description handling hybrid points\n */\n\nexport const handleHybrid = (coords, red_data, entrance_point, drop_points) => {\n  //finding the point with lowest latitude and highest longitude\n  var least_lat = 0;\n  var high_lon = 0;\n\n  for (let i = 0; i < coords.length; i++) {\n    if (coords[i].lat < coords[least_lat].lat) {\n      least_lat = i;\n    }\n\n    if (coords[high_lon].lon < coords[i].lon) {\n      high_lon = i;\n    }\n  } //building angle with equator or true horizontal\n\n\n  const horizontal = this.obtaincoordinates(coords[least_lat], 0, this.getHaversineDistance(coords[least_lat], coords[high_lon]));\n  var out = this.angle(coords[least_lat], coords[high_lon], horizontal, 1);\n  var ang;\n\n  for (let i = 0; i < entrance_point.length; i++) {\n    var theta = this.angle(coords[least_lat], coords[high_lon], entrance_point[i], 0);\n    ang = theta + out;\n    var dist = this.distance(coords[least_lat], entrance_point[i]) * 0.3048; //to convert to meter\n\n    var ver = dist * Math.sin(ang * Math.PI / 180.0);\n    var hor = dist * Math.cos(ang * Math.PI / 180.0);\n    var trans = this.obtaincoordinates(coords[least_lat], ver, hor);\n    entrance_point[i].lat = trans.lat;\n    entrance_point[i].lon = trans.lon;\n  } //loop to calculate hybrid grid's local and global coordinates\n\n\n  for (let p = 0; p < drop_points.length; p++) {\n    var final = JSON.parse(JSON.stringify(coords)); //Deep copy of original coords\n\n    var gpoint = drop_points[p]; //finding nearest corner to gpoint\n\n    var near = 0;\n\n    for (let i = 0; i < coords.length; i++) {\n      var temp = this.getHaversineDistance(gpoint, coords[i]);\n\n      if (temp < this.getHaversineDistance(gpoint, coords[near])) {\n        near = i;\n      }\n    } //angle btwn near, near+1 and gpoint\n\n\n    var p1 = near;\n\n    if (near == 3) {\n      var p2 = 0;\n    } else {\n      var p2 = near + 1;\n    }\n\n    var theta1 = this.angle(coords[p1], coords[p2], gpoint, 1); //angle btwn near, near-1 and gpoint\n\n    if (near == 0) {\n      var p3 = 3;\n    } else {\n      var p3 = near - 1;\n    }\n\n    var theta2 = this.angle(coords[p1], coords[p3], gpoint, 1); //evaluating local co-ordinates of hybrid grid\n\n    if (theta2 > 90) {\n      //finding out axis\n      if (coords[p2].localx - coords[p1].localx == 0) {\n        //xaxis\n        if (coords[p1].localx - coords[p3].localx > 0) {\n          var dist = this.perpendicular(coords[p1], coords[p2], gpoint);\n          final[p1].localx = final[p1].localx + dist;\n          final[p2].localx = final[p2].localx + dist;\n        } else if (coords[p1].localx - coords[p3].localx < 0) {\n          var dist = this.perpendicular(coords[p1], coords[p2], gpoint);\n          final[p1].localx = final[p1].localx - dist;\n          final[p2].localx = final[p2].localx - dist;\n        }\n      } else if (coords[p2].localy - coords[p1].localy == 0) {\n        //yaxis\n        if (coords[p1].localy - coords[p3].localy > 0) {\n          var dist = this.perpendicular(coords[p1], coords[p2], gpoint);\n          final[p1].localy = final[p1].localy + dist;\n          final[p2].localy = final[p2].localy + dist;\n        } else if (coords[p1].localy - coords[p3].localy < 0) {\n          var dist = this.perpendicular(coords[p1], coords[p2], gpoint);\n          final[p1].localy = final[p1].localy - dist;\n          final[p2].localy = final[p2].localy - dist;\n        }\n      }\n    }\n\n    if (theta1 > 90) {\n      //finding out axis\n      if (coords[p3].localx - coords[p1].localx == 0) {\n        //xaxis\n        var dist = this.perpendicular(coords[p1], coords[p3], gpoint);\n\n        if (coords[p1].localx - coords[p2].localx > 0) {\n          final[p1].localx = final[p1].localx + dist;\n          final[p3].localx = final[p3].localx + dist;\n        } else if (coords[p1].localx - coords[p2].localx < 0) {\n          final[p1].localx = final[p1].localx - dist;\n          final[p3].localx = final[p3].localx - dist;\n        }\n      } else if (coords[p3].localy - coords[p1].localy == 0) {\n        //yaxis\n        var dist = this.perpendicular(coords[p1], coords[p3], gpoint);\n\n        if (coords[p1].localy - coords[p2].localy > 0) {\n          final[p1].localy = final[p1].localy + dist;\n          final[p3].localy = final[p3].localy + dist;\n        } else if (coords[p1].localy - coords[p2].localy < 0) {\n          final[p1].localy = final[p1].localy - dist;\n          final[p3].localy = final[p3].localy - dist;\n        }\n      }\n    } //evaluating global co-ordinates of hybrid grid\n\n\n    var slope = (coords[high_lon].localy - coords[least_lat].localy) / (coords[high_lon].localx - coords[least_lat].localx);\n\n    for (let i = 0; i < coords.length; i++) {\n      if (final[i].localx != coords[i].localx || final[i].localy != coords[i].localy) {\n        //translating of a corner\n        //z is the line equation joining least_lat and high_lon\n        if (coords[high_lon].localx - coords[least_lat].localx == 0) {\n          var z = final[i].localx - coords[least_lat].localx;\n        } else {\n          var z = final[i].localy - coords[least_lat].localy - slope * (final[i].localx - coords[least_lat].localx);\n        }\n\n        var theta = this.angle(coords[least_lat], coords[high_lon], final[i], 0);\n\n        if (z < 0) {\n          ang = -theta + out;\n        } else {\n          ang = theta + out;\n        }\n\n        var dist = this.distance(coords[least_lat], final[i]) * 0.3048; //to convert to meter\n\n        var ver = dist * Math.sin(ang * Math.PI / 180.0);\n        var hor = dist * Math.cos(ang * Math.PI / 180.0);\n        var trans = this.obtaincoordinates(coords[least_lat], ver, hor);\n        final[i].lat = trans.lat;\n        final[i].lon = trans.lon;\n      }\n    } //correcting the hybrid vertices to remove negatives i.e translating the axes.\n\n\n    var min_x = Math.min.apply(null, final.map(function (item) {\n      return item.localx;\n    }));\n    var min_y = Math.min.apply(null, final.map(function (item) {\n      return item.localy;\n    }));\n\n    for (let i = 0; i < final.length; i++) {\n      final[i].localx -= min_x;\n      final[i].localy -= min_y;\n    } //translating entrance/any points according to new axis\n\n\n    for (let i = 0; i < entrance_point.length; i++) {\n      entrance_point[i].localx -= min_x;\n      entrance_point[i].localy -= min_y;\n    }\n\n    coords = final; //for next loop\n    //evaluating local coordinates of the DROPOFF point using perpendicular distance from axes\n\n    for (let i = 0; i < coords.length; i++) {\n      if (coords[i].localx == 0 && coords[i].localy == 0) {\n        var oo = i;\n      } //oo-> orgin\n\n\n      if (coords[i].localx == 0 && coords[i].localy != 0) {\n        var on = i;\n      } //on-> point on y-axis\n\n\n      if (coords[i].localx != 0 && coords[i].localy == 0) {\n        var no = i;\n      } //no-> point on x-axis\n\n    }\n\n    drop_points[p].localx = this.perpendicular(coords[oo], coords[on], gpoint);\n    drop_points[p].localy = this.perpendicular(coords[oo], coords[no], gpoint); //translating prev dropoff points according to new axis\n\n    for (let i = 0; i < p; i++) {\n      drop_points[i].localx -= min_x;\n      drop_points[i].localy -= min_y;\n    }\n  } //converting to geoJSON format\n\n\n  let geoJSON_ext = {\n    type: \"FeatureCollection\",\n    features: []\n  };\n  var arr = [];\n\n  for (let j = 0; j < final.length; j++) {\n    arr.push([final[j].lon, final[j].lat]);\n  }\n\n  geoJSON_ext.features.push({\n    type: \"Feature\",\n    properties: {},\n    geometry: {\n      type: \"Polygon\",\n      coordinates: [arr]\n    }\n  });\n  return geoJSON_ext;\n};\n/**\n *\n * @param {*} nonRefined\n * @param {*} refinedPoints\n * @param {*} mapElements\n * @param {*} floor\n * @id N2.1.7\n * @author Gulshan Jangid and Akhilesh Karra\n * @description generating instructions from points\n */\n\nexport const findInstructions = (nonRefined, refinedPoints, mapElements, floor) => {\n  //length of refined and non refined paths\n  let nonRefinedPoints = JSON.parse(nonRefined);\n  var nRefined = refinedPoints.length;\n  var nNonRefined = nonRefinedPoints.length; //converting the mapElements to ordered map for ease of access\n\n  var ElementMap = new Map();\n  var includedSet = new Set();\n  var word; //for iteration purpose\n\n  var currentNRPoint = 0;\n  var currentRPoint = 0;\n  var flagList = [];\n  var i = 0;\n  var j = 0; //radius defines what range to cover in a path\n\n  var radius = 3;\n  let pathTuning = []; //adding the elements to map\n\n  for (i = 0; i < mapElements.length; i++) {\n    let props = mapElements[i];\n\n    if (props.element.type === \"Rooms\") {\n      if (props.name !== \"undefined\") {\n        Object.keys(props).map(id => {\n          if (id === \"roomName\") {\n            props[`name`] = [...props[id]].join(\"\");\n            delete props[id];\n          }\n        });\n        ElementMap.set(`${props.coordinateX}@${props.coordinateY}`, mapElements[i]);\n      }\n    } else if (props.element.type === \"FloorConnection\") {\n      if (props.name !== \"undefined\") {\n        ElementMap.set(`${props.coordinateX}@${props.coordinateY}`, mapElements[i]);\n      }\n    } else if (props.element.type === \"Services\") {\n      if (props.name !== \"undefined\") ElementMap.set(`${props.coordinateX}@${props.coordinateY}`, mapElements[i]);\n    } else if (props.element.type === \"RestRooms\") {\n      if (props.name !== \"undefined\") ElementMap.set(`${props.coordinateX}@${props.coordinateY}`, mapElements[i]);\n    } else {}\n  } // //finding the indices of the\n\n\n  while (currentNRPoint < nNonRefined && currentRPoint < nRefined) {\n    if (nonRefinedPoints[currentNRPoint][0] === refinedPoints[currentRPoint].x && nonRefinedPoints[currentNRPoint][1] === refinedPoints[currentRPoint].y) {\n      flagList.push(currentNRPoint);\n      currentRPoint++;\n    }\n\n    currentNRPoint++;\n  } // Generating the direction and elaborated results\n\n\n  var DirectionResults = [];\n  var ElaboratedResults = []; //entry point insertion to the list\n\n  DirectionResults.push(\"You are at \" + ElementMap.get(\"\" + refinedPoints[0].x + \"@\" + refinedPoints[0].y).name);\n  ElaboratedResults.push(\"You are at \" + ElementMap.get(\"\" + refinedPoints[0].x + \"@\" + refinedPoints[0].y).name);\n  includedSet.add(refinedPoints[0].x + \"@\" + refinedPoints[0].y);\n  includedSet.add(refinedPoints[nRefined - 1].x + \"@\" + refinedPoints[nRefined - 1].y); //iterate and /finding the desired results\n\n  var error = 0;\n\n  for (currentRPoint = 0; currentRPoint < nRefined - 1; currentRPoint++) {\n    var angle = 0;\n    var coordinates; // this.actualAngle = 155\n\n    if (currentRPoint === 0) {\n      angle = find_angle({\n        x: refinedPoints[currentRPoint].x,\n        y: refinedPoints[currentRPoint].y + 1\n      }, refinedPoints[currentRPoint + 1], refinedPoints[currentRPoint]);\n      let path_angle = angle;\n      let floorangle = 270;\n      let diff = 360 - floorangle; // let CurrentDirection = 60;\n\n      let CurrentDirection = 0;\n      let gn = calculatePath(path_angle, diff, CurrentDirection);\n      angle = gn;\n    } else angle = find_angle(refinedPoints[currentRPoint - 1], refinedPoints[currentRPoint + 1], refinedPoints[currentRPoint]);\n\n    angle = angle + error;\n    error = findErrorInAngle(angle);\n    let hypo = 0.6 * (flagList[currentRPoint + 1] - flagList[currentRPoint]);\n    let base = Math.cos(angle) * hypo;\n    let height = Math.sin(angle) * hypo;\n    var forwardStep = parseInt(Math.abs(height));\n\n    if (hypo <= 6) {\n      console.log(forwardStep);\n    }\n\n    var lastStep = parseInt(Math.abs(base));\n    let steps = parseInt(forwardStep + hypo);\n\n    if (currentRPoint === nRefined - 2) {\n      word = findDirectionword(angle);\n      DirectionResults.push(word);\n      DirectionResults.push(\"Move \" + Math.round(0.6 * (flagList[currentRPoint + 1] - flagList[currentRPoint])) + \" steps forward\");\n      pathTuning.push({\n        points: refinedPoints[currentRPoint],\n        angle: angle,\n        base,\n        height,\n        word\n      });\n      break;\n    }\n    /* if (hypo <= 6) {\n       word = findWord(angle);\n       if (word.includes(\"Turn 0 O' Clock\")) {\n         word = \"Go straight\";\n       }\n       pathTuning.push({\n         points: refinedPoints[currentRPoint],\n         angle: angle,\n         base,\n         height,\n         word\n       });\n       DirectionResults.push(word + \" walk \" + steps + \" steps forward\");\n     } else {*/\n\n\n    word = findDirectionword(angle);\n    pathTuning.push({\n      points: refinedPoints[currentRPoint],\n      angle: angle,\n      base,\n      height,\n      word\n    });\n    let step = parseInt(Math.round(0.6 * (flagList[currentRPoint + 1] - flagList[currentRPoint])));\n    DirectionResults.push(word);\n    DirectionResults.push(\" Move \" + step + \" steps forward\"); //}\n    //this part of code handles the intermediate importatnt rooms\n\n    var begin = flagList[currentRPoint] + 1;\n    var end = flagList[currentRPoint + 1];\n\n    while (begin < end) {\n      var currpoint = nonRefinedPoints[begin];\n\n      for (i = Math.max(0, currpoint[0] - radius); i < currpoint[0] + radius; i++) {\n        for (j = Math.max(0, currpoint[1] - radius); j < currpoint[1] + radius; j++) {\n          if (!includedSet.has(i + \"@\" + j) && ElementMap.has(i + \"@\" + j)) {\n            var tempAngle = find_angle({\n              x: nonRefinedPoints[begin - 1][0],\n              y: nonRefinedPoints[begin - 1][1]\n            }, {\n              x: i,\n              y: j\n            }, {\n              x: nonRefinedPoints[begin][0],\n              y: nonRefinedPoints[begin][1]\n            });\n            ElaboratedResults.push(ElementMap.get(i + \"@\" + j).roomName + \" on your \" + findDirectionAbbreviation(tempAngle));\n            includedSet.add(i + \"@\" + j);\n          }\n        }\n      }\n\n      begin++;\n    }\n  }\n\n  let elem = ElementMap.get(\"\" + refinedPoints[nRefined - 1].x + \"@\" + refinedPoints[nRefined - 1].y);\n\n  if (elem.element.type === \"Services\" && elem.element.subType === \"Rest Rooms\") {\n    let name = `${elem.washroomType} Washroom (${elem.floor} Floor)`;\n    DirectionResults.push(\"You will reach \" + name);\n  } else if (elem.element.type === \"Services\" && elem.element.subType === \"Drinking Water | Non Drinking\") {\n    let name = `Drinking Water Point (${elem.floor} Floor)`;\n    DirectionResults.push(\"You will reach \" + name);\n  } else {\n    DirectionResults.push(\"You will reach \" + ElementMap.get(\"\" + refinedPoints[nRefined - 1].x + \"@\" + refinedPoints[nRefined - 1].y).name);\n  }\n\n  ElaboratedResults.push(\"You have reached \" + ElementMap.get(\"\" + refinedPoints[nRefined - 1].x + \"@\" + refinedPoints[nRefined - 1].y).name);\n  return DirectionResults;\n};\n/**\n *\n * @param {*} path_angle\n * @param {*} diff\n * @param {*} CurrentDirection\n * @id N2.1.9\n * @author Gulshan Jangid\n * @description calculate path\n */\n\nvar calculatePath = (path_angle, diff, CurrentDirection) => {\n  let pathGN, rotateDirection, path_angleN;\n\n  if (path_angle >= 0 && path_angle < 106) {\n    pathGN = 360 - (diff - path_angle);\n    rotateDirection = pathGN - CurrentDirection;\n  } else if (path_angle > 105 && path_angle <= 180) {\n    pathGN = path_angle - diff;\n    rotateDirection = pathGN - CurrentDirection;\n  } else if (path_angle <= -1 && path_angle >= -180) {\n    path_angleN = 180 + path_angle;\n    pathGN = path_angleN + 180 - diff;\n    rotateDirection = pathGN - CurrentDirection;\n  }\n\n  return rotateDirection;\n};\n/**\n *\n * @param {*} points\n * @param {*} tolerance\n * @id N2.1.10\n * @author Gulshan Jangid\n * @description simplify points\n */\n\n\nexport const simplifyPath = (points, tolerance) => {\n  // helper classes\n  var Vector = function (x, y) {\n    this.x = x;\n    this.y = y;\n  };\n\n  var Line = function (p1, p2) {\n    this.p1 = p1;\n    this.p2 = p2;\n\n    this.distanceToPoint = function (point) {\n      // slope\n      var m = (this.p2.y - this.p1.y) / (this.p2.x - this.p1.x),\n          // y offset\n      b = this.p1.y - m * this.p1.x,\n          d = []; // distance to the linear equation\n\n      d.push(Math.abs(point.y - m * point.x - b) / Math.sqrt(Math.pow(m, 2) + 1)); // distance to p1\n\n      d.push(Math.sqrt(Math.pow(point.x - this.p1.x, 2) + Math.pow(point.y - this.p1.y, 2))); // distance to p2\n\n      d.push(Math.sqrt(Math.pow(point.x - this.p2.x, 2) + Math.pow(point.y - this.p2.y, 2))); // return the smallest distance\n\n      return d.sort(function (a, b) {\n        return a - b; //causes an array to be sorted numerically and ascending\n      })[0];\n    };\n  };\n  /**\n   *\n   * @param {*} points\n   * @param {*} tolerance\n   * @id N2.1.11\n  * @author Gulshan Jangid\n  * @description algorithm to generate smooth line\n   */\n\n\n  var douglasPeucker = function (points, tolerance) {\n    if (points.length <= 2) {\n      return [points[0]];\n    }\n\n    var returnPoints = [],\n        // make line from start to end\n    line = new Line(points[0], points[points.length - 1]),\n        // find the largest distance from intermediate poitns to this line\n    maxDistance = 0,\n        maxDistanceIndex = 0,\n        p;\n\n    for (var i = 1; i <= points.length - 2; i++) {\n      var distance = line.distanceToPoint(points[i]);\n\n      if (distance > maxDistance) {\n        maxDistance = distance;\n        maxDistanceIndex = i;\n      }\n    } // check if the max distance is greater than our tollerance allows\n\n\n    if (maxDistance >= tolerance) {\n      p = points[maxDistanceIndex];\n      line.distanceToPoint(p, true); // include this point in the output\n\n      returnPoints = returnPoints.concat(douglasPeucker(points.slice(0, maxDistanceIndex + 1), tolerance)); // returnPoints.push( points[maxDistanceIndex] );\n\n      returnPoints = returnPoints.concat(douglasPeucker(points.slice(maxDistanceIndex, points.length), tolerance));\n    } else {\n      // ditching this point\n      p = points[maxDistanceIndex];\n      line.distanceToPoint(p, true);\n      returnPoints = [points[0]];\n    }\n\n    return returnPoints;\n  };\n\n  var arr = douglasPeucker(points, tolerance); // always have to push the very last point on so it doesn't get left off\n\n  arr.push(points[points.length - 1]);\n  return arr;\n};\n/**\n *\n * @param {*} p0\n * @param {*} p1\n * @param {*} c\n * @id N2.1.12\n * @author Gulshan Jangid\n * @description find angle\n */\n\nexport const find_angle = (p0, p1, c) => {\n  var p0c = {\n    x: c.x - p0.x,\n    y: c.y - p0.y\n  }; // p0->c (b)\n\n  var cp1 = {\n    x: p1.x - c.x,\n    y: p1.y - c.y\n  }; // p1->c (a)\n\n  return Math.atan2(cp1.y * p0c.x - cp1.x * p0c.y, p0c.x * cp1.x + p0c.y * cp1.y) * 180 / Math.PI;\n}; //Module for finding the direction's equivalent commands\n\n/**\n *\n * @param {*} angle\n * @id N2.1.13\n * @author Gulshan Jangid\n * @description find direction word\n */\n\nexport const findDirectionword = angle => {\n  if (angle >= 75 && angle <= 105) return \"Turn Right\";\n  if (angle <= -75 && angle >= -105) return \"Turn Left\";\n  if (angle >= 165 && angle <= 180 || angle <= -165 && angle >= -180) return \"Go Straight\";\n\n  if (angle < 0) {\n    if (Math.round((360 + angle) / 30) === 9) {\n      return \"Turn Left\";\n    }\n\n    return \"Turn \" + Math.round((360 + angle) / 30) + \" O' Clock\";\n  }\n\n  if (Math.floor(angle / 30) === 3) return \"Turn Right\";\n  return \"Turn \" + Math.round(angle / 30) + \" O' Clock\";\n};\n/**\n *\n * @param {*} angle\n * @id N2.1.14\n * @author Gulshan Jangid\n * @description generate word from angle\n */\n\nexport const findWord = angle => {\n  if (angle >= 75 && angle <= 105) return \"Turn Right\";\n  if (angle <= -75 && angle >= -105) return \"Turn Left\";\n  if (angle >= 165 && angle <= 180 || angle <= -165 && angle >= -180) return \"Go Straight\";\n\n  if (angle < 0) {\n    if (Math.round((360 + angle) / 30) === 9) {\n      return \"Turn Left\";\n    }\n\n    return \"Turn left\"; //   return \"Turn \" + Math.round((360 + angle) / 30) + \" O' Clock\";\n  }\n\n  if (Math.floor(angle / 30) === 3) return \"Turn Right\";\n  return \"Turn right\"; // return \"Turn \" + Math.round(angle / 30) + \" O' Clock\";\n};\n/**\n *\n * @param {*} angle\n * @id N2.1.15\n * @author Gulshan Jangid\n * @description error in angle\n */\n// find the error component in the iteration and leaves it for the next iteration\n\nexport const findErrorInAngle = angle => {\n  if (angle < 0) return 360 + angle - Math.round((360 + angle) / 30) * 30;\n  return angle - Math.round(angle / 30) * 30;\n}; //same as above but in abbreviated form\n\n/**\n *\n * @param {*} angle\n * @id N2.1.16\n * @author Gulshan Jangid\n * @description direction abbreviation\n */\n\nexport const findDirectionAbbreviation = angle => {\n  if (angle > 0) return \"Right\";\n  return \"Left\";\n};","map":{"version":3,"sources":["/home/home/navigation/src/components/dashboard/global/module.js"],"names":["getHaversineDistance","firstLocation","secondLocation","earthRadius","diffLat","lat","Math","PI","difflon","lon","arc","cos","sin","line","atan2","sqrt","distance","obtaincoordinates","reference","vertical","horizontal","R","dLat","dLon","latA","lonA","first","second","dist","localy","localx","perpendicular","one","two","three","y","x","bearing1","y2","x2","bearing2","lat1Rads","lat3Rads","distanceAC","acos","min_distance","abs","asin","angle","type","l","m","n","theta","b","c","a","handleHybrid","coords","red_data","entrance_point","drop_points","least_lat","high_lon","i","length","out","ang","ver","hor","trans","p","final","JSON","parse","stringify","gpoint","near","temp","p1","p2","theta1","p3","theta2","slope","z","min_x","min","apply","map","item","min_y","oo","on","no","geoJSON_ext","features","arr","j","push","properties","geometry","coordinates","findInstructions","nonRefined","refinedPoints","mapElements","floor","nonRefinedPoints","nRefined","nNonRefined","ElementMap","Map","includedSet","Set","word","currentNRPoint","currentRPoint","flagList","radius","pathTuning","props","element","name","Object","keys","id","join","set","coordinateX","coordinateY","DirectionResults","ElaboratedResults","get","add","error","find_angle","path_angle","floorangle","diff","CurrentDirection","gn","calculatePath","findErrorInAngle","hypo","base","height","forwardStep","parseInt","console","log","lastStep","steps","findDirectionword","round","points","step","begin","end","currpoint","max","has","tempAngle","roomName","findDirectionAbbreviation","elem","subType","washroomType","pathGN","rotateDirection","path_angleN","simplifyPath","tolerance","Vector","Line","distanceToPoint","point","d","pow","sort","douglasPeucker","returnPoints","maxDistance","maxDistanceIndex","concat","slice","p0","p0c","cp1","findWord"],"mappings":"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","sourcesContent":["//Helper function for Distance(in m) between global points\n/**\n * @param {*} firstLocation\n * @param {*} secondLocation\n * @id N2.1.1\n * @author Ushaswini Chintha\n * @description get global distance between two points\n */\nexport const getHaversineDistance = (firstLocation, secondLocation) => {\n  const earthRadius = 6371; // km //6378137; //m\n  const diffLat = ((secondLocation.lat - firstLocation.lat) * Math.PI) / 180;\n  const difflon = ((secondLocation.lon - firstLocation.lon) * Math.PI) / 180;\n  // console.log(\"difflat,difflon\",diffLat,difflon,firstLocation, secondLocation)\n  const arc =\n    Math.cos((firstLocation.lat * Math.PI) / 180) *\n      Math.cos((secondLocation.lat * Math.PI) / 180) *\n      Math.sin(difflon / 2) *\n      Math.sin(difflon / 2) +\n    Math.sin(diffLat / 2) * Math.sin(diffLat / 2);\n  const line = 2 * Math.atan2(Math.sqrt(arc), Math.sqrt(1 - arc));\n  const distance = earthRadius * line * 1000;\n  return distance;\n};\n//calculates Gcoordinates with given vertical and horizontal distance (should be in meters) from a refrence point\n/**\n * @param {*} reference\n * @param {*} vertical\n * @param {*} horizontal\n * @id N2.1.2\n * @author Ushaswini Chintha\n * @description get coordinates from reference points\n */\nexport const obtaincoordinates = (reference, vertical, horizontal) => {\n  const R = 6378137; //Earthâ€™s radius, sphere\n  //Coordinate offsets in radians\n  var dLat = vertical / R;\n  var dLon = horizontal / (R * Math.cos((Math.PI * reference.lat) / 180));\n  //OffsetPosition, decimal degrees\n  var latA = reference.lat + (dLat * 180) / Math.PI;\n  var lonA = reference.lon + (dLon * 180) / Math.PI;\n  return { lat: latA, lon: lonA };\n};\n/**\n *\n * @param {*} first\n * @param {*} second\n * @id N2.1.3\n * @author Ushaswini Chintha\n * @description distance between two coorinates\n */\n//helper function for distance between two points in local coordinates\nexport const distance = (first, second) => {\n  var dist =\n    (second.localy - first.localy) ** 2 + (second.localx - first.localx) ** 2;\n  return Math.sqrt(dist);\n};\n/**\n *\n * @param {*} one\n * @param {*} two\n * @param {*} three\n * @id N2.1.4\n * @author Ushaswini Chintha\n * @description get perpendicalr from 3 points\n */\n//perpendicular distance of point(three) from a line formed by one and two\nexport const perpendicular = (one, two, three) => {\n  var y = Math.sin(three.lon - one.lon) * Math.cos(three.lat);\n  var x =\n    Math.cos(one.lat) * Math.sin(three.lat) -\n    Math.sin(one.lat) * Math.cos(three.lat) * Math.cos(three.lat - one.lat);\n  var bearing1 = (Math.atan2(y, x) * 180) / Math.PI;\n  bearing1 = 360 - ((bearing1 + 360) % 360);\n  var y2 = Math.sin(two.lon - one.lon) * Math.cos(two.lat);\n  var x2 =\n    Math.cos(one.lat) * Math.sin(two.lat) -\n    Math.sin(one.lat) * Math.cos(two.lat) * Math.cos(two.lat - one.lat);\n  var bearing2 = (Math.atan2(y2, x2) * 180) / Math.PI;\n  bearing2 = 360 - ((bearing2 + 360) % 360);\n  var lat1Rads = (one.lat * Math.PI) / 180;\n  var lat3Rads = (three.lat * Math.PI) / 180;\n  var dLon = ((three.lon - one.lon) * Math.PI) / 180;\n  var distanceAC =\n    Math.acos(\n      Math.sin(lat1Rads) * Math.sin(lat3Rads) +\n        Math.cos(lat1Rads) * Math.cos(lat3Rads) * Math.cos(dLon)\n    ) * 6371;\n  var min_distance = Math.abs(\n    Math.asin(\n      Math.sin(distanceAC / 6371) *\n        Math.sin((bearing1 * Math.PI) / 180 - (bearing2 * Math.PI) / 180)\n    ) * 6371\n  );\n  // console.log(\"The perpendicular distance is: \", min_distance*1000*3.28084);\n  return min_distance * 1000 * 3.28084;\n};\n//angle between three points; type:0 -> normal_distance, type:1 -> haversine_distance\n/**\n *\n * @param {*} one\n * @param {*} two\n * @param {*} three\n * @param {*} type\n * @id N2.1.5\n * @author Ushaswini Chintha\n * @description angle between reference points\n */\nexport const angle = (one, two, three, type) => {\n  if (type == 0) {\n    //calulated using normal_distance\n    var l = this.distance(one, two);\n    var m = this.distance(two, three);\n    var n = this.distance(one, three);\n    var theta =\n      (Math.acos((l * l + n * n - m * m) / (2 * l * n)) * 180) / Math.PI;\n    if ((l * l + n * n - m * m) / (2 * l * n) > 1 || m == 0 || n == 0) {\n      theta = 0;\n    } //straight line case\n    if ((l * l + n * n - m * m) / (2 * l * n) < -1) {\n      theta = 180;\n    } //straight line case\n  } else if (type == 1) {\n    //calulated using haverisine_distance\n    var b = this.getHaversineDistance(one, two);\n    var c = this.getHaversineDistance(one, three);\n    var a = this.getHaversineDistance(two, three);\n    var theta =\n      (Math.acos((b * b + c * c - a * a) / (2 * b * c)) * 180) / Math.PI;\n    if ((b * b + c * c - a * a) / (2 * b * c) > 1 || a == 0 || c == 0) {\n      theta = 0;\n    } //straight line case\n    if ((b * b + c * c - a * a) / (2 * b * c) < -1) {\n      theta = 180;\n    } //straight line case\n  }\n  return theta;\n};\n/**\n *\n * @param {*} coords\n * @param {*} red_data\n * @param {*} entrance_point\n * @param {*} drop_points\n * @id N2.1.6\n * @author Ushaswini Chintha\n * @description handling hybrid points\n */\nexport const handleHybrid = (coords, red_data, entrance_point, drop_points) => {\n  //finding the point with lowest latitude and highest longitude\n  var least_lat = 0;\n  var high_lon = 0;\n  for (let i = 0; i < coords.length; i++) {\n    if (coords[i].lat < coords[least_lat].lat) {\n      least_lat = i;\n    }\n    if (coords[high_lon].lon < coords[i].lon) {\n      high_lon = i;\n    }\n  }\n  //building angle with equator or true horizontal\n  const horizontal = this.obtaincoordinates(\n    coords[least_lat],\n    0,\n    this.getHaversineDistance(coords[least_lat], coords[high_lon])\n  );\n  var out = this.angle(coords[least_lat], coords[high_lon], horizontal, 1);\n  var ang;\n  for (let i = 0; i < entrance_point.length; i++) {\n    var theta = this.angle(\n      coords[least_lat],\n      coords[high_lon],\n      entrance_point[i],\n      0\n    );\n    ang = theta + out;\n    var dist = this.distance(coords[least_lat], entrance_point[i]) * 0.3048; //to convert to meter\n    var ver = dist * Math.sin((ang * Math.PI) / 180.0);\n    var hor = dist * Math.cos((ang * Math.PI) / 180.0);\n    var trans = this.obtaincoordinates(coords[least_lat], ver, hor);\n    entrance_point[i].lat = trans.lat;\n    entrance_point[i].lon = trans.lon;\n  }\n  //loop to calculate hybrid grid's local and global coordinates\n  for (let p = 0; p < drop_points.length; p++) {\n    var final = JSON.parse(JSON.stringify(coords)); //Deep copy of original coords\n    var gpoint = drop_points[p];\n    //finding nearest corner to gpoint\n    var near = 0;\n    for (let i = 0; i < coords.length; i++) {\n      var temp = this.getHaversineDistance(gpoint, coords[i]);\n      if (temp < this.getHaversineDistance(gpoint, coords[near])) {\n        near = i;\n      }\n    }\n    //angle btwn near, near+1 and gpoint\n    var p1 = near;\n    if (near == 3) {\n      var p2 = 0;\n    } else {\n      var p2 = near + 1;\n    }\n    var theta1 = this.angle(coords[p1], coords[p2], gpoint, 1);\n    //angle btwn near, near-1 and gpoint\n    if (near == 0) {\n      var p3 = 3;\n    } else {\n      var p3 = near - 1;\n    }\n    var theta2 = this.angle(coords[p1], coords[p3], gpoint, 1);\n    //evaluating local co-ordinates of hybrid grid\n    if (theta2 > 90) {\n      //finding out axis\n      if (coords[p2].localx - coords[p1].localx == 0) {\n        //xaxis\n        if (coords[p1].localx - coords[p3].localx > 0) {\n          var dist = this.perpendicular(coords[p1], coords[p2], gpoint);\n          final[p1].localx = final[p1].localx + dist;\n          final[p2].localx = final[p2].localx + dist;\n        } else if (coords[p1].localx - coords[p3].localx < 0) {\n          var dist = this.perpendicular(coords[p1], coords[p2], gpoint);\n          final[p1].localx = final[p1].localx - dist;\n          final[p2].localx = final[p2].localx - dist;\n        }\n      } else if (coords[p2].localy - coords[p1].localy == 0) {\n        //yaxis\n        if (coords[p1].localy - coords[p3].localy > 0) {\n          var dist = this.perpendicular(coords[p1], coords[p2], gpoint);\n          final[p1].localy = final[p1].localy + dist;\n          final[p2].localy = final[p2].localy + dist;\n        } else if (coords[p1].localy - coords[p3].localy < 0) {\n          var dist = this.perpendicular(coords[p1], coords[p2], gpoint);\n          final[p1].localy = final[p1].localy - dist;\n          final[p2].localy = final[p2].localy - dist;\n        }\n      }\n    }\n    if (theta1 > 90) {\n      //finding out axis\n      if (coords[p3].localx - coords[p1].localx == 0) {\n        //xaxis\n        var dist = this.perpendicular(coords[p1], coords[p3], gpoint);\n        if (coords[p1].localx - coords[p2].localx > 0) {\n          final[p1].localx = final[p1].localx + dist;\n          final[p3].localx = final[p3].localx + dist;\n        } else if (coords[p1].localx - coords[p2].localx < 0) {\n          final[p1].localx = final[p1].localx - dist;\n          final[p3].localx = final[p3].localx - dist;\n        }\n      } else if (coords[p3].localy - coords[p1].localy == 0) {\n        //yaxis\n        var dist = this.perpendicular(coords[p1], coords[p3], gpoint);\n        if (coords[p1].localy - coords[p2].localy > 0) {\n          final[p1].localy = final[p1].localy + dist;\n          final[p3].localy = final[p3].localy + dist;\n        } else if (coords[p1].localy - coords[p2].localy < 0) {\n          final[p1].localy = final[p1].localy - dist;\n          final[p3].localy = final[p3].localy - dist;\n        }\n      }\n    }\n    //evaluating global co-ordinates of hybrid grid\n    var slope =\n      (coords[high_lon].localy - coords[least_lat].localy) /\n      (coords[high_lon].localx - coords[least_lat].localx);\n    for (let i = 0; i < coords.length; i++) {\n      if (\n        final[i].localx != coords[i].localx ||\n        final[i].localy != coords[i].localy\n      ) {\n        //translating of a corner\n        //z is the line equation joining least_lat and high_lon\n        if (coords[high_lon].localx - coords[least_lat].localx == 0) {\n          var z = final[i].localx - coords[least_lat].localx;\n        } else {\n          var z =\n            final[i].localy -\n            coords[least_lat].localy -\n            slope * (final[i].localx - coords[least_lat].localx);\n        }\n        var theta = this.angle(\n          coords[least_lat],\n          coords[high_lon],\n          final[i],\n          0\n        );\n        if (z < 0) {\n          ang = -theta + out;\n        } else {\n          ang = theta + out;\n        }\n        var dist = this.distance(coords[least_lat], final[i]) * 0.3048; //to convert to meter\n        var ver = dist * Math.sin((ang * Math.PI) / 180.0);\n        var hor = dist * Math.cos((ang * Math.PI) / 180.0);\n        var trans = this.obtaincoordinates(coords[least_lat], ver, hor);\n        final[i].lat = trans.lat;\n        final[i].lon = trans.lon;\n      }\n    }\n    //correcting the hybrid vertices to remove negatives i.e translating the axes.\n    var min_x = Math.min.apply(\n      null,\n      final.map(function(item) {\n        return item.localx;\n      })\n    );\n    var min_y = Math.min.apply(\n      null,\n      final.map(function(item) {\n        return item.localy;\n      })\n    );\n    for (let i = 0; i < final.length; i++) {\n      final[i].localx -= min_x;\n      final[i].localy -= min_y;\n    }\n    //translating entrance/any points according to new axis\n    for (let i = 0; i < entrance_point.length; i++) {\n      entrance_point[i].localx -= min_x;\n      entrance_point[i].localy -= min_y;\n    }\n    coords = final; //for next loop\n    //evaluating local coordinates of the DROPOFF point using perpendicular distance from axes\n    for (let i = 0; i < coords.length; i++) {\n      if (coords[i].localx == 0 && coords[i].localy == 0) {\n        var oo = i;\n      } //oo-> orgin\n      if (coords[i].localx == 0 && coords[i].localy != 0) {\n        var on = i;\n      } //on-> point on y-axis\n      if (coords[i].localx != 0 && coords[i].localy == 0) {\n        var no = i;\n      } //no-> point on x-axis\n    }\n    drop_points[p].localx = this.perpendicular(coords[oo], coords[on], gpoint);\n    drop_points[p].localy = this.perpendicular(coords[oo], coords[no], gpoint);\n    //translating prev dropoff points according to new axis\n    for (let i = 0; i < p; i++) {\n      drop_points[i].localx -= min_x;\n      drop_points[i].localy -= min_y;\n    }\n  }\n  //converting to geoJSON format\n  let geoJSON_ext = {\n    type: \"FeatureCollection\",\n    features: []\n  };\n  var arr = [];\n  for (let j = 0; j < final.length; j++) {\n    arr.push([final[j].lon, final[j].lat]);\n  }\n  geoJSON_ext.features.push({\n    type: \"Feature\",\n    properties: {},\n    geometry: {\n      type: \"Polygon\",\n      coordinates: [arr]\n    }\n  });\n  return geoJSON_ext;\n};\n/**\n *\n * @param {*} nonRefined\n * @param {*} refinedPoints\n * @param {*} mapElements\n * @param {*} floor\n * @id N2.1.7\n * @author Gulshan Jangid and Akhilesh Karra\n * @description generating instructions from points\n */\nexport const findInstructions = (\n  nonRefined,\n  refinedPoints,\n  mapElements,\n  floor\n) => {\n  //length of refined and non refined paths\n  let nonRefinedPoints = JSON.parse(nonRefined);\n  var nRefined = refinedPoints.length;\n  var nNonRefined = nonRefinedPoints.length;\n  //converting the mapElements to ordered map for ease of access\n  var ElementMap = new Map();\n  var includedSet = new Set();\n  var word;\n  //for iteration purpose\n  var currentNRPoint = 0;\n  var currentRPoint = 0;\n  var flagList = [];\n  var i = 0;\n  var j = 0;\n  //radius defines what range to cover in a path\n  var radius = 3;\n  let pathTuning = [];\n  //adding the elements to map\n  for (i = 0; i < mapElements.length; i++) {\n    let props = mapElements[i];\n    if (props.element.type === \"Rooms\") {\n      if (props.name !== \"undefined\") {\n        Object.keys(props).map(id => {\n          if (id === \"roomName\") {\n            props[`name`] = [...props[id]].join(\"\");\n            delete props[id];\n          }\n        });\n        ElementMap.set(\n          `${props.coordinateX}@${props.coordinateY}`,\n          mapElements[i]\n        );\n      }\n    } else if (props.element.type === \"FloorConnection\") {\n      if (props.name !== \"undefined\") {\n        ElementMap.set(\n          `${props.coordinateX}@${props.coordinateY}`,\n          mapElements[i]\n        );\n      }\n    } else if (props.element.type === \"Services\") {\n      if (props.name !== \"undefined\")\n        ElementMap.set(\n          `${props.coordinateX}@${props.coordinateY}`,\n          mapElements[i]\n        );\n    } else if (props.element.type === \"RestRooms\") {\n      if (props.name !== \"undefined\")\n        ElementMap.set(\n          `${props.coordinateX}@${props.coordinateY}`,\n          mapElements[i]\n        );\n    } else {\n    }\n  }\n  // //finding the indices of the\n  while (currentNRPoint < nNonRefined && currentRPoint < nRefined) {\n    if (\n      nonRefinedPoints[currentNRPoint][0] === refinedPoints[currentRPoint].x &&\n      nonRefinedPoints[currentNRPoint][1] === refinedPoints[currentRPoint].y\n    ) {\n      flagList.push(currentNRPoint);\n      currentRPoint++;\n    }\n    currentNRPoint++;\n  }\n  // Generating the direction and elaborated results\n  var DirectionResults = [];\n  var ElaboratedResults = [];\n  //entry point insertion to the list\n  DirectionResults.push(\n    \"You are at \" +\n      ElementMap.get(\"\" + refinedPoints[0].x + \"@\" + refinedPoints[0].y).name\n  );\n  ElaboratedResults.push(\n    \"You are at \" +\n      ElementMap.get(\"\" + refinedPoints[0].x + \"@\" + refinedPoints[0].y).name\n  );\n  includedSet.add(refinedPoints[0].x + \"@\" + refinedPoints[0].y);\n  includedSet.add(\n    refinedPoints[nRefined - 1].x + \"@\" + refinedPoints[nRefined - 1].y\n  );\n  //iterate and /finding the desired results\n  var error = 0;\n  for (currentRPoint = 0; currentRPoint < nRefined - 1; currentRPoint++) {\n    var angle = 0;\n    var coordinates;\n    // this.actualAngle = 155\n    if (currentRPoint === 0) {\n      angle = find_angle(\n        {\n          x: refinedPoints[currentRPoint].x,\n          y: refinedPoints[currentRPoint].y + 1\n        },\n        refinedPoints[currentRPoint + 1],\n        refinedPoints[currentRPoint]\n      );\n      let path_angle = angle;\n      let floorangle = 270;\n      let diff = 360 - floorangle;\n      // let CurrentDirection = 60;\n      let CurrentDirection = 0;\n      let gn = calculatePath(path_angle, diff, CurrentDirection);\n      angle = gn;\n    } else\n      angle = find_angle(\n        refinedPoints[currentRPoint - 1],\n        refinedPoints[currentRPoint + 1],\n        refinedPoints[currentRPoint]\n      );\n    angle = angle + error;\n    error = findErrorInAngle(angle);\n    let hypo = 0.6 * (flagList[currentRPoint + 1] - flagList[currentRPoint]);\n    let base = Math.cos(angle) * hypo;\n    let height = Math.sin(angle) * hypo;\n    var forwardStep = parseInt(Math.abs(height));\n   if(hypo<=6){\n    console.log(forwardStep);}\n    var lastStep = parseInt(Math.abs(base));\n    let steps = parseInt(forwardStep + hypo);\n    if (currentRPoint === nRefined - 2) {\n      word = findDirectionword(angle);\n      DirectionResults.push(word);\n      DirectionResults.push(\n        \"Move \" +\n          Math.round(\n            0.6 * (flagList[currentRPoint + 1] - flagList[currentRPoint])\n          ) +\n          \" steps forward\"\n      );\n      pathTuning.push({\n        points: refinedPoints[currentRPoint],\n        angle: angle,\n        base,\n        height,\n        word\n      });\n      break;\n    }\n   /* if (hypo <= 6) {\n      word = findWord(angle);\n      if (word.includes(\"Turn 0 O' Clock\")) {\n        word = \"Go straight\";\n      }\n      pathTuning.push({\n        points: refinedPoints[currentRPoint],\n        angle: angle,\n        base,\n        height,\n        word\n      });\n      DirectionResults.push(word + \" walk \" + steps + \" steps forward\");\n    } else {*/\n      word = findDirectionword(angle);\n      pathTuning.push({\n        points: refinedPoints[currentRPoint],\n        angle: angle,\n        base,\n        height,\n        word\n      });\n      let step = parseInt(\n        Math.round(\n          0.6 * (flagList[currentRPoint + 1] - flagList[currentRPoint])\n        )\n      );\n      DirectionResults.push(word);\n      DirectionResults.push(\" Move \" + step + \" steps forward\");\n    //}\n    //this part of code handles the intermediate importatnt rooms\n    var begin = flagList[currentRPoint] + 1;\n    var end = flagList[currentRPoint + 1];\n\n    while (begin < end) {\n      var currpoint = nonRefinedPoints[begin];\n      for (\n        i = Math.max(0, currpoint[0] - radius);\n        i < currpoint[0] + radius;\n        i++\n      ) {\n        for (\n          j = Math.max(0, currpoint[1] - radius);\n          j < currpoint[1] + radius;\n          j++\n        ) {\n          if (!includedSet.has(i + \"@\" + j) && ElementMap.has(i + \"@\" + j)) {\n            var tempAngle = find_angle(\n              {\n                x: nonRefinedPoints[begin - 1][0],\n                y: nonRefinedPoints[begin - 1][1]\n              },\n              { x: i, y: j },\n              { x: nonRefinedPoints[begin][0], y: nonRefinedPoints[begin][1] }\n            );\n            ElaboratedResults.push(\n              ElementMap.get(i + \"@\" + j).roomName +\n                \" on your \" +\n                findDirectionAbbreviation(tempAngle)\n            );\n            includedSet.add(i + \"@\" + j);\n          }\n        }\n      }\n      begin++;\n    }\n  }\n  let elem = ElementMap.get(\n    \"\" + refinedPoints[nRefined - 1].x + \"@\" + refinedPoints[nRefined - 1].y\n  );\n  if (\n    elem.element.type === \"Services\" &&\n    elem.element.subType === \"Rest Rooms\"\n  ) {\n    let name = `${elem.washroomType} Washroom (${elem.floor} Floor)`;\n    DirectionResults.push(\"You will reach \" + name);\n  } else if (\n    elem.element.type === \"Services\" &&\n    elem.element.subType === \"Drinking Water | Non Drinking\"\n  ) {\n    let name = `Drinking Water Point (${elem.floor} Floor)`;\n    DirectionResults.push(\"You will reach \" + name);\n  } else {\n    DirectionResults.push(\n      \"You will reach \" +\n        ElementMap.get(\n          \"\" +\n            refinedPoints[nRefined - 1].x +\n            \"@\" +\n            refinedPoints[nRefined - 1].y\n        ).name\n    );\n  }\n  ElaboratedResults.push(\n    \"You have reached \" +\n      ElementMap.get(\n        \"\" + refinedPoints[nRefined - 1].x + \"@\" + refinedPoints[nRefined - 1].y\n      ).name\n  );\n  return DirectionResults;\n};\n/**\n *\n * @param {*} path_angle\n * @param {*} diff\n * @param {*} CurrentDirection\n * @id N2.1.9\n * @author Gulshan Jangid\n * @description calculate path\n */\nvar calculatePath = (path_angle, diff, CurrentDirection) => {\n  let pathGN, rotateDirection, path_angleN;\n  if (path_angle >= 0 && path_angle < 106) {\n    pathGN = 360 - (diff - path_angle);\n    rotateDirection = pathGN - CurrentDirection;\n  } else if (path_angle > 105 && path_angle <= 180) {\n    pathGN = path_angle - diff;\n    rotateDirection = pathGN - CurrentDirection;\n  } else if (path_angle <= -1 && path_angle >= -180) {\n    path_angleN = 180 + path_angle;\n    pathGN = path_angleN + 180 - diff;\n    rotateDirection = pathGN - CurrentDirection;\n  }\n  return rotateDirection;\n};\n/**\n *\n * @param {*} points\n * @param {*} tolerance\n * @id N2.1.10\n * @author Gulshan Jangid\n * @description simplify points\n */\nexport const simplifyPath = (points, tolerance) => {\n  // helper classes\n  var Vector = function(x, y) {\n    this.x = x;\n    this.y = y;\n  };\n  var Line = function(p1, p2) {\n    this.p1 = p1;\n    this.p2 = p2;\n    this.distanceToPoint = function(point) {\n      // slope\n      var m = (this.p2.y - this.p1.y) / (this.p2.x - this.p1.x),\n        // y offset\n        b = this.p1.y - m * this.p1.x,\n        d = [];\n      // distance to the linear equation\n      d.push(\n        Math.abs(point.y - m * point.x - b) / Math.sqrt(Math.pow(m, 2) + 1)\n      );\n      // distance to p1\n      d.push(\n        Math.sqrt(\n          Math.pow(point.x - this.p1.x, 2) + Math.pow(point.y - this.p1.y, 2)\n        )\n      );\n      // distance to p2\n      d.push(\n        Math.sqrt(\n          Math.pow(point.x - this.p2.x, 2) + Math.pow(point.y - this.p2.y, 2)\n        )\n      );\n      // return the smallest distance\n      return d.sort(function(a, b) {\n        return a - b; //causes an array to be sorted numerically and ascending\n      })[0];\n    };\n  };\n  /**\n   *\n   * @param {*} points\n   * @param {*} tolerance\n   * @id N2.1.11\n * @author Gulshan Jangid\n * @description algorithm to generate smooth line\n   */\n  var douglasPeucker = function(points, tolerance) {\n    if (points.length <= 2) {\n      return [points[0]];\n    }\n    var returnPoints = [],\n      // make line from start to end\n      line = new Line(points[0], points[points.length - 1]),\n      // find the largest distance from intermediate poitns to this line\n      maxDistance = 0,\n      maxDistanceIndex = 0,\n      p;\n    for (var i = 1; i <= points.length - 2; i++) {\n      var distance = line.distanceToPoint(points[i]);\n      if (distance > maxDistance) {\n        maxDistance = distance;\n        maxDistanceIndex = i;\n      }\n    }\n    // check if the max distance is greater than our tollerance allows\n    if (maxDistance >= tolerance) {\n      p = points[maxDistanceIndex];\n      line.distanceToPoint(p, true);\n      // include this point in the output\n      returnPoints = returnPoints.concat(\n        douglasPeucker(points.slice(0, maxDistanceIndex + 1), tolerance)\n      );\n      // returnPoints.push( points[maxDistanceIndex] );\n      returnPoints = returnPoints.concat(\n        douglasPeucker(points.slice(maxDistanceIndex, points.length), tolerance)\n      );\n    } else {\n      // ditching this point\n      p = points[maxDistanceIndex];\n      line.distanceToPoint(p, true);\n      returnPoints = [points[0]];\n    }\n    return returnPoints;\n  };\n  var arr = douglasPeucker(points, tolerance);\n  // always have to push the very last point on so it doesn't get left off\n  arr.push(points[points.length - 1]);\n  return arr;\n};\n/**\n *\n * @param {*} p0\n * @param {*} p1\n * @param {*} c\n * @id N2.1.12\n * @author Gulshan Jangid\n * @description find angle\n */\nexport const find_angle = (p0, p1, c) => {\n  var p0c = { x: c.x - p0.x, y: c.y - p0.y }; // p0->c (b)\n  var cp1 = { x: p1.x - c.x, y: p1.y - c.y }; // p1->c (a)\n  return (\n    (Math.atan2(cp1.y * p0c.x - cp1.x * p0c.y, p0c.x * cp1.x + p0c.y * cp1.y) *\n      180) /\n    Math.PI\n  );\n};\n//Module for finding the direction's equivalent commands\n/**\n *\n * @param {*} angle\n * @id N2.1.13\n * @author Gulshan Jangid\n * @description find direction word\n */\nexport const findDirectionword = angle => {\n  if (angle >= 75 && angle <= 105) return \"Turn Right\";\n  if (angle <= -75 && angle >= -105) return \"Turn Left\";\n  if ((angle >= 165 && angle <= 180) || (angle <= -165 && angle >= -180))\n    return \"Go Straight\";\n  if (angle < 0) {\n    if (Math.round((360 + angle) / 30) === 9) {\n      return \"Turn Left\";\n    }\n    return \"Turn \" + Math.round((360 + angle) / 30) + \" O' Clock\";\n  }\n  if (Math.floor(angle / 30) === 3) return \"Turn Right\";\n  return \"Turn \" + Math.round(angle / 30) + \" O' Clock\";\n};\n/**\n *\n * @param {*} angle\n * @id N2.1.14\n * @author Gulshan Jangid\n * @description generate word from angle\n */\nexport const findWord = angle => {\n  if (angle >= 75 && angle <= 105) return \"Turn Right\";\n  if (angle <= -75 && angle >= -105) return \"Turn Left\";\n  if ((angle >= 165 && angle <= 180) || (angle <= -165 && angle >= -180))\n    return \"Go Straight\";\n  if (angle < 0) {\n    if (Math.round((360 + angle) / 30) === 9) {\n      return \"Turn Left\";\n    }\n    return \"Turn left\";\n    //   return \"Turn \" + Math.round((360 + angle) / 30) + \" O' Clock\";\n  }\n  if (Math.floor(angle / 30) === 3) return \"Turn Right\";\n  return \"Turn right\";\n  // return \"Turn \" + Math.round(angle / 30) + \" O' Clock\";\n};\n/**\n *\n * @param {*} angle\n * @id N2.1.15\n * @author Gulshan Jangid\n * @description error in angle\n */\n// find the error component in the iteration and leaves it for the next iteration\nexport const findErrorInAngle = angle => {\n  if (angle < 0) return 360 + angle - Math.round((360 + angle) / 30) * 30;\n  return angle - Math.round(angle / 30) * 30;\n};\n//same as above but in abbreviated form\n/**\n *\n * @param {*} angle\n * @id N2.1.16\n * @author Gulshan Jangid\n * @description direction abbreviation\n */\nexport const findDirectionAbbreviation = angle => {\n  if (angle > 0) return \"Right\";\n  return \"Left\";\n};\n"]},"metadata":{},"sourceType":"module"}