{"ast":null,"code":"var polyline = {}; // Based off of [the offical Google document](https://developers.google.com/maps/documentation/utilities/polylinealgorithm)\n//\n// Some parts from [this implementation](http://facstaff.unca.edu/mcmcclur/GoogleMaps/EncodePolyline/PolylineEncoder.js)\n// by [Mark McClure](http://facstaff.unca.edu/mcmcclur/)\n\nfunction encode(coordinate, factor) {\n  coordinate = Math.round(coordinate * factor);\n  coordinate <<= 1;\n\n  if (coordinate < 0) {\n    coordinate = ~coordinate;\n  }\n\n  var output = '';\n\n  while (coordinate >= 0x20) {\n    output += String.fromCharCode((0x20 | coordinate & 0x1f) + 63);\n    coordinate >>= 5;\n  }\n\n  output += String.fromCharCode(coordinate + 63);\n  return output;\n} // This is adapted from the implementation in Project-OSRM\n// https://github.com/DennisOSRM/Project-OSRM-Web/blob/master/WebContent/routing/OSRM.RoutingGeometry.js\n\n\npolyline.decode = function (str, precision) {\n  var index = 0,\n      lat = 0,\n      lng = 0,\n      coordinates = [],\n      shift = 0,\n      result = 0,\n      byte = null,\n      latitude_change,\n      longitude_change,\n      factor = Math.pow(10, precision || 5); // Coordinates have variable length when encoded, so just keep\n  // track of whether we've hit the end of the string. In each\n  // loop iteration, a single coordinate is decoded.\n\n  while (index < str.length) {\n    // Reset shift, result, and byte\n    byte = null;\n    shift = 0;\n    result = 0;\n\n    do {\n      byte = str.charCodeAt(index++) - 63;\n      result |= (byte & 0x1f) << shift;\n      shift += 5;\n    } while (byte >= 0x20);\n\n    latitude_change = result & 1 ? ~(result >> 1) : result >> 1;\n    shift = result = 0;\n\n    do {\n      byte = str.charCodeAt(index++) - 63;\n      result |= (byte & 0x1f) << shift;\n      shift += 5;\n    } while (byte >= 0x20);\n\n    longitude_change = result & 1 ? ~(result >> 1) : result >> 1;\n    lat += latitude_change;\n    lng += longitude_change;\n    coordinates.push([lat / factor, lng / factor]);\n  }\n\n  return coordinates;\n};\n\npolyline.encode = function (coordinates, precision) {\n  if (!coordinates.length) return '';\n  var factor = Math.pow(10, precision || 5),\n      output = encode(coordinates[0][0], factor) + encode(coordinates[0][1], factor);\n\n  for (var i = 1; i < coordinates.length; i++) {\n    var a = coordinates[i],\n        b = coordinates[i - 1];\n    output += encode(a[0] - b[0], factor);\n    output += encode(a[1] - b[1], factor);\n  }\n\n  return output;\n};\n\nif (typeof module !== undefined) module.exports = polyline;","map":{"version":3,"sources":["/home/home/navigation/node_modules/polyline/src/polyline.js"],"names":["polyline","encode","coordinate","factor","Math","round","output","String","fromCharCode","decode","str","precision","index","lat","lng","coordinates","shift","result","byte","latitude_change","longitude_change","pow","length","charCodeAt","push","i","a","b","module","undefined","exports"],"mappings":"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","sourcesContent":["var polyline = {};\n\n// Based off of [the offical Google document](https://developers.google.com/maps/documentation/utilities/polylinealgorithm)\n//\n// Some parts from [this implementation](http://facstaff.unca.edu/mcmcclur/GoogleMaps/EncodePolyline/PolylineEncoder.js)\n// by [Mark McClure](http://facstaff.unca.edu/mcmcclur/)\n\nfunction encode(coordinate, factor) {\n    coordinate = Math.round(coordinate * factor);\n    coordinate <<= 1;\n    if (coordinate < 0) {\n        coordinate = ~coordinate;\n    }\n    var output = '';\n    while (coordinate >= 0x20) {\n        output += String.fromCharCode((0x20 | (coordinate & 0x1f)) + 63);\n        coordinate >>= 5;\n    }\n    output += String.fromCharCode(coordinate + 63);\n    return output;\n}\n\n// This is adapted from the implementation in Project-OSRM\n// https://github.com/DennisOSRM/Project-OSRM-Web/blob/master/WebContent/routing/OSRM.RoutingGeometry.js\npolyline.decode = function(str, precision) {\n    var index = 0,\n        lat = 0,\n        lng = 0,\n        coordinates = [],\n        shift = 0,\n        result = 0,\n        byte = null,\n        latitude_change,\n        longitude_change,\n        factor = Math.pow(10, precision || 5);\n\n    // Coordinates have variable length when encoded, so just keep\n    // track of whether we've hit the end of the string. In each\n    // loop iteration, a single coordinate is decoded.\n    while (index < str.length) {\n\n        // Reset shift, result, and byte\n        byte = null;\n        shift = 0;\n        result = 0;\n\n        do {\n            byte = str.charCodeAt(index++) - 63;\n            result |= (byte & 0x1f) << shift;\n            shift += 5;\n        } while (byte >= 0x20);\n\n        latitude_change = ((result & 1) ? ~(result >> 1) : (result >> 1));\n\n        shift = result = 0;\n\n        do {\n            byte = str.charCodeAt(index++) - 63;\n            result |= (byte & 0x1f) << shift;\n            shift += 5;\n        } while (byte >= 0x20);\n\n        longitude_change = ((result & 1) ? ~(result >> 1) : (result >> 1));\n\n        lat += latitude_change;\n        lng += longitude_change;\n\n        coordinates.push([lat / factor, lng / factor]);\n    }\n\n    return coordinates;\n};\n\npolyline.encode = function(coordinates, precision) {\n    if (!coordinates.length) return '';\n\n    var factor = Math.pow(10, precision || 5),\n        output = encode(coordinates[0][0], factor) + encode(coordinates[0][1], factor);\n\n    for (var i = 1; i < coordinates.length; i++) {\n        var a = coordinates[i], b = coordinates[i - 1];\n        output += encode(a[0] - b[0], factor);\n        output += encode(a[1] - b[1], factor);\n    }\n\n    return output;\n};\n\nif (typeof module !== undefined) module.exports = polyline;\n"]},"metadata":{},"sourceType":"script"}